```{r log}
theLog <- file( "wip.log", open = "wt")
sink(theLog, type = "message")
```
```{r, echo= FALSE, }

source('definitions.R')
```
```{r}
source("loadData.R")
#kable(JHHUSStates)
```
```{r check vaccinations countries}
vax <- readOwidvax() %>% rename(PSCR = location)
names(vax)
names(JHHTest)
setdiff( vax$PSCR %>% unique , JHH$Province.State %>% unique)
setdiff( JHH$PSCR %>% unique, vax$PSCR %>% unique)

JHHtest<- JHH%>% filter(PSCR == "Belgium") %>% select(PSCR, confirmed, theDate)%>% 
            merge(vax,  all.x = TRUE, by.x = c("PSCR", "theDate"),
               by.y = c("PSCR", "theDate") , sort  = TRUE) %>%  
            group_by(PSCR) %>% 
            fill(people_fully_vaccinated, people_vaccinated, total_vaccinations,total_vaccinations_per_hundred,
                 people_vaccinated_per_hundred, people_fully_vaccinated_per_hundred, 
                 .direction = "down")  %>%  #na.locf is fill in tidyverse
            mutate(  across(.cols = c("total_vaccinations", "people_vaccinated", "people_fully_vaccinated",
                              "daily_vaccinations_raw" , 'daily_vaccinations','total_vaccinations_per_hundred', 
                              'people_vaccinated_per_hundred', 'people_fully_vaccinated_per_hundred', 
                              'daily_vaccinations_per_million'), .fns = ~ifelse(is.na(.x),0,.x))) %>% #impute zeros before Vaccinations started. 
            View()

JHH%>% filter(PSCR == "Taiwan*") %>% select(people_fully_vaccinated, people_vaccinated, total_vaccinations, theDate)%>% View
popbelgie = 11422068
```
```{r}
JHH %>% filter(PSCR =="Belgium") %>% pull(new_active_rate) %>% unique() %>% sort()
JHH %>% graph1dnar_iyl(c("Belgium","Netherlands","France","Germany"),logy = FALSE, xvar = "theDate", from = "2020-10-10")
```
```{r}
graph6Ddrausf_fiMa(countries = c("Belgium","Netherlands","Germany","United Kingdom","France","Malta","Israel","Russia","Chile"))
```
```{r}
graphDdrasf_fiMa(countries = c("Belgium","Netherlands","Germany","United Kingdom","France","Malta","Israel","Russia","Chile"), scale = "free")
```
## a Danny Dorling plot: val by Delta val, for active_imputed. It shows vertical zig zags
```{r}
graph1cd_finl(JHH, JHH.Regios$`JHH Europe2`, size =1, scales = "fixed", logy = T, logx = T, slope = FALSE) # savename = "Europe2",
graph1cd_finl(JHH, JHH.Regios$`JHH Europe1`, size =1, scales = "fixed", slope = FALSE)
graph1cd_finl(JHH, JHH.Regios$`JHH World1`, size = 1, scales = "fixed" , slope = deathRate)#, savename = "World1")
=lifecycle::last_warnings()
# there is an error in a subset where the index is a df instead of a vertor.
```
```{r do deaths by new_deaths}
graph1aa_fiMnl(JHH, countries = c("France","Serbia","Italy","Belgium", "Germany","United Kingdom"), xvar = "new_deaths_p_M", yvar ="deaths_p_M")

```
```{r #check placement of in graph legend. }
graphDanny(ECDC,  c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_bottom.polygons", putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.points",putlegend = FALSE, facet = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.points",putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.polygons", putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_top.qp",putlegend = FALSE)
graph1aa_finl(JHH, c("Italy","Belgium","Netherlands","Germany","Poland","Ukraine", "Russia","Spain","Portugal"),  savename = " Spain to Portugal")
graph1aa_finl(JHH, c("Italy","Belgium","Netherlands","Germany","Poland","Ukraine", "Russia","Spain","Portugal"),  scales = "fixed")
graph1aa_finl(JHH, c(regios$Vincent, "USA", "Europe"),  savename = "VF")
graph1aa_finl(JHH, regios$MSM,   savename = "MSM Countries")
graph1cd_finl(JHH, c(regios$Vincent, "USA", "Europe"),  savename = "VF")
```
```{r}


```
```{r}
graph1cd_finl(Belgium, "Brussels" )
graph1aa_finl(Belgium,"Brussels")# Belgium.Regios[1])


graph1aa_finl(JHH, c("Spain", "France"), labmeth = "dl_top.qp")
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), labmeth = "dl_top.qp")
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), labmeth = "dl_top.points",  logy = TRUE)

graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 1, labmeth = "repel_label", putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 1, labmeth = "repel_text",
              putlegend = FALSE)
 
```


```{r}
sink()
myGraphNrs
```
```{r test walkthrough on ECDC}
Graphlist1 = c( "graph1Da_finl",        "graph1dnar_iyl",       "graph1dr_iyl" )
Graphlist2 = c("graph1Drr_il", "graph2aa_inl", "graph2crd_il", "graph2dac_iyl" )
Graphlist3 = c("graph3Dard_fia", "graph3Dard_fina", "graph6Dardcra_fiMnyl", "graph6Dardcra_fiMyl")
Graphlist4 = c("graph6Dardcra_finyl",  "graph6Dardcra_fiyl")
myGraphNrs = "graph1aa_finl"
verbose = 6

walkThrough( lpdf = ECDC, regions = ECDC.Regios, graphlist = myGraphNrs, myFolderDate  = 'current', ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDC.Regios, graphlist = c('graph6Dardcra_fiyl', 'graph6Dardcra_finyl', "graph6Dardcra_fiMnyl", "graph6Dardcra_fiMyl","graph1cd_finl" ,"graph3Dard_fia","graph3Dard_fina", "graph1aa_finl", "graph1aa_fiMnl"), myFolderDate  = 'current', ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDC.Regios, graphlist = c("graph1Da_fil"   ,"graph1Da_finl",  "graph1Dc_fnl",   "graph1dnar_iyl", "graph1dr_iyl" ), myFolderDate  = 'current', ordre = 'RG')
```
```{r}
sink(type = "output")
setdiff(myGraphNrs, c('graph6Dardcra_fiyl', 'graph6Dardcra_finyl', "graph6Dardcra_fiMnyl", "graph6Dardcra_fiMyl","graph1cd_finl" ,"graph3Dard_fia","graph3Dard_fina", "graph1aa_finl", "graph1aa_fiMnl"))
```
# to trace the nested calls leading to an error, use: 
traceback()

```{r}
JHH[JHH$Country.Region %in% c("Netherlands","Belgium") & JHH$theDate>= "2020-10-24",] %>% 
  group_by(PSCR) %>% 
  nest %>% 
  mutate( data = map(data, function(d) smoothem.tib(d,vars = "net_active_imputed", n = 6))) %>% 
  unnest(data)
```
```{r}

graph1aa_finl(JHH, countries = c("Netherlands","Belgium"))
graph1aa_fiMnl(JHH, countries = c("Netherlands","Belgium"))
#graph1aa_finl(JHH,c("Netherlands"),ID="Country.Region")
graph1aa_finl(JHH,c("Aruba,Netherlands","Curacao,Netherlands","Sint Maarten,Netherlands"),ID="PSCR")
graphdanny(JHH , c("France", "Germany"))
graphdanny(JHH , c( "Germany"), smoothn  = 7)

graphOnRegion(lpdf = JHH, JHHRegios$MSM, "graph1aa_finl", saveit = TRUE)
```

```{r}
print(graph2aa_inl(JHH,c( "Netherlands"))%>% tail )
graph1Da_fil(ECDC, "Belgium", saveit = TRUE)
```
```{r}
source("graphit.R")
source("graphdanny.R")
verbose = 2
graphdanny(JHH, "France", labmeth = "repel_label")
graphdanny(JHH, "France", smoothn = 7,labmeth = "repel_label")
graphdanny(JHH , c("France","Spain", "Italy", "Germany"), smoothn  = FALSE,labmeth = "repel_label")
graphdanny(JHH , c("Spain", "Italy"), smoothn  = 7,)
graph6Dardcra_finyl(JHH, "Belgium", smoothn = 7)
graph3Dard_fina(JHH, "Belgium", smoothn = 7)

```

```{r test labels}
regios$Vincent <- list("Vincent", "Belgium","France","Germany","Netherlands")
#unchanged: 
source("definitions.R")
graphit(JHH, regios$Vincent, xvar = 'day', logx = FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), putlegend = FALSE)
source("graphit.R") 
graphit(JHH, regios$Vincent, xvar = 'day', logx = FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), putlegend = FALSE)
graphit(JHH, regios$Vincent, xvar = 'day', logx = FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_points', putlegend = FALSE)

graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_last.points', putlegend = TRUE)
```


```{r smoothed}
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'),  smoothn= 7, labmeth = 'dl_last.points', putlegend = TRUE)

graphit(JHH, regios$Vincent, xvar = 'day', logx =  FALSE , logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'repel_label', putlegend = FALSE)
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'repel_text')
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_polygon')
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_bumpup', putlegend = TRUE)
JHH%>% select(new_confirmed, theDate) %>% filter( PSCR %in% regios$Vincent) %>% filter(theDate == max(theDate))
```

```{r}


```

```{r very verbose and warnings become errors}
options(warn = 2)
```
```{r less verbose}
verbose <-  1
```

```{r}
checkTotals3 <- function(lpti = ECDC0, totregions , ID = 'Region'){
  if (missing(totregions)) totregions <- unique(lpti[[ID]])
  lpti1 <- lpti  %>% filter(!(!!ID %in% totregions)) 
  #just to be sure, that if i do it twice i dont get double counts. We will get double entries tho! 
  #this might show up in the graphs or not depending on sorting. 
  varnames  = c("confirmed",  "deaths", "population") 
  #Africa totals recovered and active seem to mirror imputed values. 
  if (!('Lat' %in% names(lpti))) lpti1$Lat <- NA
  if (!('Long' %in% names(lpti))) lpti1$Long <- NA
  if (!all(sort(names(lpti)) == sort(names( lpti  %>%  total("", varnames = varnames, newrow = "World")) )))
    {print(sort(names( lpti  %>%  total("", varnames = varnames, newrow = "World"))))
    print("while " )
    print(sort(names(lpti)))
  }
  else TRUE  
}
  names(total(ECDC0, 'Europe' , ID = 'Region', varnames = c('confirmed','deaths'), newrow = 'Europe'))

```

```{r}
checkTotals3(ECDC0 %>% rename(theDate = Date), 'Europe' , ID = 'Region')
```

# alternative sortIDlevels version which does not work. because of metaprogramming issues with arrange. 
```{r}
sortIDlevels.dplyr <- function(lpdf, varname = confirmed, ondate = ""){
  varname <- enquo(varname)
  if (ondate  == "") {ondate = max(lpdf$theDate) } else 
    if (nrow(lpdf[lpdf$theDate  ==  ondate, ]  == 0)) {
      stop("Cannot sort on values of a date which is not present in the Data")}
  PSCRlevels <- lpdf  %>%  select(c(PSCR, theDate, !!varname))  %>%  
    filter(theDate  == ondate)  %>%  
    arrange(-eval(parse(text = substitute(!!varname))), PSCR, .by_group  = FALSE) 
  arrange(desc({{varname}}), PSCR, .by_group  = FALSE) 
  #arrange(-(!!varname), PSCR, .by_group  = FALSE) 
  lpdf <- lpdf %>% ungroup %>%  mutate(PSCR = factor(lpdf$PSCR, levels = PSCRlevels$PSCR)) %>% 
    group_by(PSCR)
  lpdf$PSCR
} #the desc eval parse substitute !! should have been desc !! according to the manuals. but desc does not respect unquo. 
```
```{r}
JHH %>% filter(PSCR == "Belgium") %>% ysmooth("ma", c("new_confirmed", "net_active")) %>% #names #select(c(new_confirmed, net_active)) 
  tail

JHH %>% filter(PSCR == "Belgium")  %>%  #select(c(new_confirmed, net_active)) %>% 
  tail
     
```





# check addSimVars
```{r}
lpti <- ECDC[ECDC$PSCR %in% c("Cases_on_an_international_conveyance_Japan", "Cayman_Islands", "Central_African_Republic"),]
minVal <- 100; minDate = '2019-12-31'; maxDate = Sys.Date()

 for (country in countries <- unique(lpti$PSCR)) {
   
   if (any(is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))) { 
     print(country % % 'nrows' % % nrRows % % newnrRows) 
     print(which((is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))))}
 }

```

```{r}
country <- 'Cayman_Islands' 
print(which((is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))))
lpti[lpti$PSCR == country & lpti$confirmed >= minVal & lpti$theDate >= minDate & lpti$theDate <=  maxDate,] %>% view
```

```{r}
lpti %>% view
lpti %>% addSimVars(minVal = 100) #error. 
lpti <- ECDC[ECDC$PSCR %in% c("Cases_on_an_international_conveyance_Japan", "Cayman_Islands"),]
lpti %>% addSimVars(minVal = 100) #no error. 

```

```{r}
lpti[lpti$confirmed_doublingDays < 0, ] %>% view #39 totally NA rows 
lpti[is.na(lpti$confirmed_doublingDays), ] %>% view # 3172 rows

```

```{r}
ECDC[is.na(ECDC$PSCR),] %>% view()   #0 rows. 
E10 <- ECDC %>% addSimVars(minVal = 100) #error with Cayman_Islands
#
```

```{r do Europe}
lpti <- ECDC[ECDC$PSCR == 'Europe',]
lpti %>% addSimVars(minDate = Sys.Date() - 10, ext = "_endsim2") %>% view #one row less. 
options(warn = 2)
E10 <- ECDC %>% addSimVars(minDate = Sys.Date() - 10, ext = "_endsim") # europe -1 extra row generated this is ok. it was because Spain delivers data later. 
# 2020-07-05 data:  UK has 7 out of 11 rows. 2020-07-03: 10 out of 11
#
## also, NAs produced by rpois (42 times) and 
# In `[<-.data.frame`(`*tmp*`, lpti$PSCR == country, , value = structure(list( ... :
#provided 51 variables to replace 47 variables
```


# integrate testing into ECDC & JHH
```{r}
a <- merge(ECDC, testing, by.x = c('ISOcode','theDate'), by.y = c('ISOcode','theDate'), all.x = TRUE,
           sort = FALSE)
names(testing)
```
# from loaddata: trial to make the loading only happen if it gives new data
```{r}
while((Sys.time()>Sys.Date()% % "22:00:00")| max(JHH$theDate) < Sys.Date()-1 ) {
   source("loaddata.R")
   if (max(JHH$theDate)< Sys.Date() - 1)     {
    print( "failed to get yesterday's values ") 
   for (i in 1:12){
    print(Sys.time())
   Sys.sleep(600)
}   } }
```


# 12 ggplot extensions: ggcorplot, 
# https://mode.com/blog/r-ggplot-extension-packages
