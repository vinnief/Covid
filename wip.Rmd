```{r log}
theLog <- file( "wip.log", open = "wt")
sink(theLog, type = "message")
```
```{r, echo= FALSE, }

source('definitions.R')
```
```{r}
source("loadData.R")
JHH[JHH$PSCR %in% JHH.Regios$`JHH World15` , ] %>% select (PSCR, theDate, deaths,recovered) %>% view
```
```{r}
walkThrough(lpdf = JHH, graphList = "graph1dr_iyl", regions = JHH.Regios$`JHH World17`)
walkThrough(lpdf = JHH, graphList = "graph1dr_iyl", regions = JHH.Regios$`JHH World16`, logx=TRUE) # St Kitts and Nevis
walkThrough(lpdf = JHH, graphList = "graph1dr_iyl", regions = JHH.Regios ,#$`JHH World15`,
            logx=TRUE)
graph1dr_iyl(JHH, c("Hong Kong,China"))
graph1sc_fMnl(JHH, c( "Peru"))

walkThrough(lpdf = JHH, graphList = "graph1sc_fMnl", regions = JHH.Regios,#$`JHH World15`,
            myFolderDate  = 'random', from = 2021/01/01, slope = FALSE) #logx=TRUE
```
```{r}
graphfcd_fiMnyl(JHH, c("Belgium","Israel"), logy = F)
graphfcd_fiMnyl(JHH, c("Belgium","Israel"), logy = 'arcsinh', logx=T)
graphfcd_fiMnyl(JHH, c("Belgium","Netherlands","France","Israel","United Kingdom"), logy = F)
graphfcd_fiMnyl(JHH,c('United Arab Emirates', "Israel",'Kuwait','Chile','Mongolia', 'Slovakia','Ireland',' Hungary','Czechia','Bosnia i Herzegovina', 'North Macedonia','United Kingdom'), logy=F)
JHH %>% filter(!is.na(people_fully_vaccinated_p_M)) %>% filter(people_fully_vaccinated>=1) %>% 
  walkThrough( graphList = "graphfcd_fiMnyl", regions = JHH.Regios,
            myFolderDate  = 'Current')

JHH$Country.Region %>% unique %>% sort # , fixed = T)
```
```{r}
graphfcd_fiMnyl(JHH, c("Bangladesh", "Belgium","Bosnia & Herzegovina","Chile", "Czechia", "France", "Hungary", "Ireland", "Israel", "Kuwait", 'Mongolia', "Nepal","Netherlands", "North Macedonia", "Slovakia", 'United Arab Emirates', "United Kingdom"), logy = "log2", from ='2021/05/01')
graphfcd_fiMnyl(JHH, c( "Bangladesh", "Belgium","Bosnia & Herzegovina","Chile", "Czechia", "France", "Hungary", "Ireland", "Israel", "Kuwait", 'Mongolia', "Nepal","Netherlands", "North Macedonia", "Slovakia", 'United Arab Emirates', "United Kingdom"), logy = F, from ='2021/01/01')

```
```{r}
walkThrough(JHH, graphList = "graphfcd_fiMnyl", 
   regions = 
     (JHH %>% makeDynRegions(byVar = "people_fully_vaccinated_p_M", piecename = "World"))[1:4],
            myFolderDate = "current", from = '2021/01/01', logy="log2")#, sortVar = "people_fully_vaccinated_p_M")
walkThrough(lpdf = JHH, graphList = "graph1vc_fhMnl", regions = JHH.Regios,
            myFolderDate  = 'random', from = 2021/01/01)
walkThrough(lpdf = JHH, graphList = "graph1fc_fhMnl",# regions = JHH.Regios,
            myFolderDate  = 'random', from = 2021/01/01)
```


```{r regios}
graph6Ddrausf_fiMa(JHH, "France",ID = "Country.Region")
graph6Ddrausf_fiMa(JHH, "United Kingdom",ID = "Country.Region")
graph3Dard_fina(JHH, "Denmark",ID = "Country.Region")
```
```{r}
regiosP <<- makeRegiosP(JHH)
setdiff(JHH$PSCR %>% unique, flatten_chr(regiosP))
setdiff( flatten_chr(regiosP), JHH$PSCR %>% unique)
JHH$Country.Region %>% unique
JHH %>% filter(Region == "World" ) %>% select(PSCR,Country.Region,Province.State) %>% unique

JHH%>% filter(Region == "Benelux")
graph6Ddrausf_fia(JHH, "Benelux",ID = "Region", sortVar = "active_imputed_p_M")
verbose = 7
source("definitions.R")
graph6Ddrausf_fia( JHH ,regiosP$Benelux, xvar = "theDate" , sortVar = "people_vaccinated_p_M", sorted = TRUE)
graph5Ddrasf_fiMa( JHH ,regiosP$Benelux, xvar = "theDate" , sortVar = "people_vaccinated_p_M", sorted = TRUE)
walkThrough(graphList = "graph5Ddrasf_fiMa", lpdf = JHH, regions = JHH.Regios,   myFolderDate  = 'current', ordre = 'RG')
sink()
names(JHH)
colors() #%>% grepl("gray", fixed = TRUE)
```


```{r check vaccinations countries}
vax <- readOwidvax() %>% rename(PSCR = location)
names(vax)
setdiff( vax$PSCR %>% unique , JHH$Province.State %>% unique)
setdiff( JHH$PSCR %>% unique, vax$PSCR %>% unique)

JHH%>% filter(PSCR == "Taiwan*") %>% select(people_fully_vaccinated, people_vaccinated, total_vaccinations, theDate)%>% View
popbelgie = 11422068

walkThrough( lpdf = JHH,  graphList = myGraphNrs, #regions = JHH.Regios,
             myFolderDate  = 'test1', ordre = 'RG')
```
```{r}
JHH %>% filter(PSCR =="Belgium") %>% pull(new_active_rate) %>% unique() %>% sort()
JHH %>% graph1dnar_iyl(c("Belgium","Netherlands","France","Germany"),logy = FALSE, xvar = "theDate", from = "2020-10-10")
```
```{r}
graph6Ddrausf_fiMa(countries = c("Belgium","Netherlands","Germany","United Kingdom","France","Malta","Israel","Russia","Chile"))
```
```{r}
graphDdrasf_fiMa(countries = c("Belgium","Netherlands","Germany","United Kingdom","France","Malta","Israel","Russia","Chile"), scale = "free")
```

```{r do deaths by new_deaths}
graph1aa_fiMnl(JHH, countries = c("France","Serbia","Italy","Belgium", "Germany","United Kingdom"), xvar = "new_deaths_p_M", yvar ="deaths_p_M")

```
```{r #check placement of in graph legend. }
graphDanny(ECDC,  c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_bottom.polygons", putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.points",putlegend = FALSE, facet = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.points",putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.polygons", putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_top.qp",putlegend = FALSE)
graph1aa_finl(JHH, c("Italy","Belgium","Netherlands","Germany","Poland","Ukraine", "Russia","Spain","Portugal"),  savename = " Spain to Portugal")
graph1aa_finl(JHH, c("Italy","Belgium","Netherlands","Germany","Poland","Ukraine", "Russia","Spain","Portugal"),  scales = "fixed")
graph1aa_finl(JHH, c(regios$Vincent, "USA", "Europe"),  savename = "VF")
graph1aa_finl(JHH, regios$MSM,   savename = "MSM Countries")
graph1cd_finl(JHH, c(regios$Vincent, "USA", "Europe"),  savename = "VF")
```
```{r}


```
```{r}
graph1cd_finl(Belgium, "Brussels" )
graph1aa_finl(Belgium,"Brussels")# Belgium.Regios[1])


graph1aa_finl(JHH, c("Spain", "France"), labmeth = "dl_top.qp")
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), labmeth = "dl_top.qp")
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), labmeth = "dl_top.points",  logy = TRUE)

graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 1, labmeth = "repel_label", putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 1, labmeth = "repel_text",
              putlegend = FALSE)
 
```
```{r}

test<- makeUSPlaces()%>% mutate(PSCR = Place %,% Region )
View(test)
unique(test$Country)
names(test)
#test<- test  %>% mutate(PSCR = Place %,% Region%,% Country )
test<- test  %>% 
  addPopulation() %>% #addCountryTotals() %>% addRegionTotals() %>%
    addRegions( Regiolist = regios) %>% addVax() %>% 
  imputeRecovered() %>% extravars() 
test.Regions <- makeDynRegions(test, piecename = "USA")
graph1aa_finl(test, test$PSCR %>% unique %>% head)
walkThrough(test, regions = test.Regions, graphList = "graph1aa_finl")
``` 
```{r}
t<- makeCovidData("regions")
t %>% head(20) %>% view
```
```{r coviddata git web data test}
test<- makeCovidData(typeOfPlace = "regions") 
test %>% head(101) %>% view
nrow(t)
test<- test  %>% 
  addPopulation() %>% #addCountryTotals() %>% addRegionTotals() %>%
  #  addRegions( Regiolist = regios) %>% 
  addVax() %>% 
  imputeRecovered() %>% extravars() 
test.Regions <- makeDynRegions(test, piecename = paste(keyVars,collapse = ", ") )
graph1aa_finl(test, test$PSCR %>% unique %>% head)
walkThrough(test, regions = test.Regions, graphList = "graph1aa_finl")


test<- makeCovidData("countries") 
test %>%  head(10) %>% view
test<- makeCovidData(typeOfPlace = "places")
test %>% head(10)
```
# to trace the nested calls leading to an error, use: 
traceback()

```{r}
JHH[JHH$Country.Region %in% c("Netherlands","Belgium") & JHH$theDate>= "2020-10-24",] %>% 
  group_by(PSCR) %>% 
  nest %>% 
  mutate( data = map(data, function(d) smoothem.tib(d,vars = "net_active_imputed", n = 6))) %>% 
  unnest(data)
```


```{r very verbose and warnings become errors}
options(warn = 2)
```
```{r less verbose}
verbose <-  1
```

```{r}
checkTotals3 <- function(lpti = ECDC0, totregions , ID = 'Region'){
  if (missing(totregions)) totregions <- unique(lpti[[ID]])
  lpti1 <- lpti  %>% filter(!(!!ID %in% totregions)) 
  #just to be sure, that if i do it twice i dont get double counts. We will get double entries tho! 
  #this might show up in the graphs or not depending on sorting. 
  varnames  = c("confirmed",  "deaths", "population") 
  #Africa totals recovered and active seem to mirror imputed values. 
  if (!('Lat' %in% names(lpti))) lpti1$Lat <- NA
  if (!('Long' %in% names(lpti))) lpti1$Long <- NA
  if (!all(sort(names(lpti)) == sort(names( lpti  %>%  total("", varnames = varnames, newrow = "World")) )))
    {print(sort(names( lpti  %>%  total("", varnames = varnames, newrow = "World"))))
    print("while " )
    print(sort(names(lpti)))
  }
  else TRUE  
}
  names(total(ECDC0, 'Europe' , ID = 'Region', varnames = c('confirmed','deaths'), newrow = 'Europe'))

```

```{r}
checkTotals3(ECDC0 %>% rename(theDate = Date), 'Europe' , ID = 'Region')
```

# alternative sortIDlevels version which does not work. because of metaprogramming issues with arrange. 
```{r}
sortIDlevels.dplyr <- function(lpdf, varname = confirmed, ondate = ""){
  varname <- enquo(varname)
  if (ondate  == "") {ondate = max(lpdf$theDate) } else 
    if (nrow(lpdf[lpdf$theDate  ==  ondate, ]  == 0)) {
      stop("Cannot sort on values of a date which is not present in the Data")}
  PSCRlevels <- lpdf  %>%  select(c(PSCR, theDate, !!varname))  %>%  
    filter(theDate  == ondate)  %>%  
    arrange(-eval(parse(text = substitute(!!varname))), PSCR, .by_group  = FALSE) 
  arrange(desc({{varname}}), PSCR, .by_group  = FALSE) 
  #arrange(-(!!varname), PSCR, .by_group  = FALSE) 
  lpdf <- lpdf %>% ungroup %>%  mutate(PSCR = factor(lpdf$PSCR, levels = PSCRlevels$PSCR)) %>% 
    group_by(PSCR)
  lpdf$PSCR
} #the desc eval parse substitute !! should have been desc !! according to the manuals. but desc does not respect unquo. 
```
```{r}
JHH %>% filter(PSCR == "Belgium") %>% ysmooth("ma", c("new_confirmed", "net_active")) %>% #names #select(c(new_confirmed, net_active)) 
  tail

JHH %>% filter(PSCR == "Belgium")  %>%  #select(c(new_confirmed, net_active)) %>% 
  tail
     
```





# check addSimVars
```{r}
lpti <- ECDC[ECDC$PSCR %in% c("Cases_on_an_international_conveyance_Japan", "Cayman_Islands", "Central_African_Republic"),]
minVal <- 100; minDate = '2019-12-31'; maxDate = Sys.Date()

 for (country in countries <- unique(lpti$PSCR)) {
   
   if (any(is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))) { 
     print(country % % 'nrows' % % nrRows % % newnrRows) 
     print(which((is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))))}
 }

```

```{r}
country <- 'Cayman_Islands' 
print(which((is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))))
lpti[lpti$PSCR == country & lpti$confirmed >= minVal & lpti$theDate >= minDate & lpti$theDate <=  maxDate,] %>% view
```

```{r}
lpti %>% view
lpti %>% addSimVars(minVal = 100) #error. 
lpti <- ECDC[ECDC$PSCR %in% c("Cases_on_an_international_conveyance_Japan", "Cayman_Islands"),]
lpti %>% addSimVars(minVal = 100) #no error. 

```

```{r}
lpti[lpti$confirmed_doublingDays < 0, ] %>% view #39 totally NA rows 
lpti[is.na(lpti$confirmed_doublingDays), ] %>% view # 3172 rows

```

```{r}
ECDC[is.na(ECDC$PSCR),] %>% view()   #0 rows. 
E10 <- ECDC %>% addSimVars(minVal = 100) #error with Cayman_Islands
#
```

```{r do Europe}
lpti <- ECDC[ECDC$PSCR == 'Europe',]
lpti %>% addSimVars(minDate = Sys.Date() - 10, ext = "_endsim2") %>% view #one row less. 
options(warn = 2)
E10 <- ECDC %>% addSimVars(minDate = Sys.Date() - 10, ext = "_endsim") # europe -1 extra row generated this is ok. it was because Spain delivers data later. 
# 2020-07-05 data:  UK has 7 out of 11 rows. 2020-07-03: 10 out of 11
#
## also, NAs produced by rpois (42 times) and 
# In `[<-.data.frame`(`*tmp*`, lpti$PSCR == country, , value = structure(list( ... :
#provided 51 variables to replace 47 variables
```


# integrate testing into ECDC & JHH
```{r}
a <- merge(ECDC, testing, by.x = c('ISOcode','theDate'), by.y = c('ISOcode','theDate'), all.x = TRUE,
           sort = FALSE)
names(testing)
```
# from loaddata: trial to make the loading only happen if it gives new data
```{r}
while((Sys.time()>Sys.Date()% % "22:00:00")| max(JHH$theDate) < Sys.Date()-1 ) {
   source("loaddata.R")
   if (max(JHH$theDate)< Sys.Date() - 1)     {
    print( "failed to get yesterday's values ") 
   for (i in 1:12){
    print(Sys.time())
   Sys.sleep(600)
}   } }
```


# 12 ggplot extensions: ggcorplot, 
# https://mode.com/blog/r-ggplot-extension-packages
