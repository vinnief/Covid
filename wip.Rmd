```{r, echo= FALSE, }
verbose <- 7
source('definitions.R')
```
```{r}
source("loadData.R")
```
```{r test graphdanny} 
graphdanny(JHH , c("Texas,US", "France", "Germany"), smoothn  = 7)
graphaa_inl(JHH , c("Texas,US", "France", "Germany"), smoothn  = 7)
```
```{r}
verbose = 2
graphdanny(JHH, JHHRegios$`JHH World2`, smoothn = 7) #to be deprecated
graphaa_inl(ECDC, ECDCRegios$`ECDC World1`, smoothn = 7,labmeth = "dl_last.points", putlegend == FALSE)
graphaa_inl(ECDC, ECDCRegios$`ECDC World2`, smoothn = 7,labmeth = "dl_last.points", putlegend == FALSE)

```
```{r}
graphdanny(JHH,  c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_bottom.polygons", putlegend = FALSE)
graphaa_inl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.points",putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_top.qp",putlegend = FALSE)
```
```{r}
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.polygons", putlegend = FALSE)
graphaa_inl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_last.points", putlegend = FALSE)
```
```{r}
graph1aa_finl(JHH, c("Spain", "France"), smoothn  = 7, labmeth = "dl_top.qp", putlegend = FALSE)

graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_top.qp",  putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 7, labmeth = "dl_top.points",  logy = TRUE, putlegend = FALSE)

graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 1, labmeth = "repel_label", putlegend = FALSE)
graph1aa_finl(JHH, c("Belgium","Netherlands","Sweden"), smoothn  = 1, labmeth = "repel_text",
              putlegend = FALSE)

```


```{r}
myGraphNrs
```
```{r test walkthrough}
Graphlist = c( "graph1Da_finl",        "graph1dnar_iyl",       "graph1dr_iyl" )
Graphlist = c("graph1Drr_il", "graph2aa_inl", "graph2crd_il", "graph2dac_iyl" )
Graphlist = c("graph3Dard_fia", "graph3Dard_fina", "graph6Dardcra_fiMnyl", "graph6Dardcra_fiMyl")
Graphlist = c("graph6Dardcra_finyl",  "graph6Dardcra_fiyl")
myGraphNrs = "graph1aa_finl"
verbose = 6
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = "graphaa_inl", myFolderDate  = 'current',  ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = 'graph3Dard_fina',
             myFolderDate  = 'current', ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = 'graph3Dard_fia',
                          myFolderDate  = 'current', ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = "graph1aa_inl", myFolderDate  = 'current',  ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = "graph6Dardcra_finl", myFolderDate  = 'current',  ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = 'graph6Dardcra_fiMnl',
             myFolderDate  = 'current', ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = 'graph6Dardcra_fil',
                          myFolderDate  = 'current', ordre = 'RG')
walkThrough( lpdf = JHH, regions = JHHRegios, graphlist = 'graph6Dardcra_fiMl',
             myFolderDate  = 'current', ordre = 'RG')
walkThrough( lpdf = ECDC, regions = ECDCRegios, graphlist = myGraphNrs,
             myFolderDate  = 'current', ordre = 'RG')

walkThrough( lpdf = JHH, regions = JHHRegios[14:17], graphlist = myGraphNrs, 
             myFolderDate  = 'current', ordre = 'RG')
graph1aa_finl(ECDC,c("Belgium","Netherlands",  "Sweden", "Kazakhstan"), smoothn = 1)
graph1aa_finl(ECDC,c("Belgium","Netherlands",  "Sweden", "Kazakhstan"))

graph1aa_finl(JHH,c("Belgium","Netherlands", "Sweden", "Kazakhstan"))
graph1aa_finl(JHH,c("Belgium","Netherlands", "Sweden", "Kazakhstan"), smoothn = 1)
 
```
traceback() # to trace the nested calls leading to an error. 

```{r}
JHH[JHH$Country.Region %in% c("Netherlands","Belgium") & JHH$theDate>= "2020-10-24",] %>% 
  group_by(PSCR) %>% 
  nest %>% 
  mutate( data = map(data, function(d) smoothem.tib(d,vars = "net_active_imputed", n = 6))) %>% 
  unnest(data)
```
```{r}

graph1aa_finl(JHH, countries = c("Netherlands","Belgium"))
graph1aa_finl(JHH, countries = c("Belgium"), smoothn = 7)
#graph1aa_finl(JHH,c("Netherlands"),ID="Country.Region")
graph1aa_finl(JHH,c("Aruba,Netherlands","Curacao,Netherlands","Sint Maarten,Netherlands"),ID="PSCR")
graphdanny(JHH , c("France", "Germany"))
graphdanny(JHH , c( "Germany"), smoothn  = 7)

graphOnRegion(lpdf = JHH, JHHRegios$MSM, "graph1aa_finl", saveit = TRUE)
```

```{r}
print(graph2aa_inl(JHH,c( "Netherlands"))%>% tail )
graph1Da_fil(ECDC, "Belgium", saveit = TRUE)
```
```{r}
source("graphit.R")
source("graphdanny.R")
verbose = 2
graphdanny(JHH, "France", labmeth = "repel_label")
graphdanny(JHH, "France", smoothn = 7,labmeth = "repel_label")
graphdanny(JHH , c("France","Spain", "Italy", "Germany"), smoothn  = FALSE,labmeth = "repel_label")
graphdanny(JHH , c("Spain", "Italy"), smoothn  = 7,)
graph6Dardcra_finyl(JHH, "Belgium", smoothn = 7)
graph3Dard_fina(JHH, "Belgium", smoothn = 7)

```

```{r test labels}
regios$Vincent <- list("Vincent", "Belgium","France","Germany","Netherlands")
#unchanged: 
source("definitions.R")
graphit(JHH, regios$Vincent, xvar = 'day', logx = FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), putlegend = FALSE)
source("graphit.R") 
graphit(JHH, regios$Vincent, xvar = 'day', logx = FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), putlegend = FALSE)
graphit(JHH, regios$Vincent, xvar = 'day', logx = FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_points', putlegend = FALSE)

graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_last.points', putlegend = TRUE)
```


```{r smoothed}
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'),  smoothn= 7, labmeth = 'dl_last.points', putlegend = TRUE)

graphit(JHH, regios$Vincent, xvar = 'day', logx =  FALSE , logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'repel_label', putlegend = FALSE)
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'repel_text')
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_polygon')
graphit(JHH, regios$Vincent, xvar = 'day', logx =    FALSE, logy = TRUE, from = "2020-08-01",
          yvars = c('new_confirmed'), labmeth = 'dl_bumpup', putlegend = TRUE)
JHH%>% select(new_confirmed, theDate) %>% filter( PSCR %in% regios$Vincent) %>% filter(theDate == max(theDate))
```

```{r}


```

```{r very verbose and warnings become errors}
options(warn = 2)
```
```{r less verbose}
verbose <-  1
```

```{r}
checkTotals3 <- function(lpti = ECDC0, totregions , ID = 'Region'){
  if (missing(totregions)) totregions <- unique(lpti[[ID]])
  lpti1 <- lpti  %>% filter(!(!!ID %in% totregions)) 
  #just to be sure, that if i do it twice i dont get double counts. We will get double entries tho! 
  #this might show up in the graphs or not depending on sorting. 
  varnames  = c("confirmed",  "deaths", "population") 
  #Africa totals recovered and active seem to mirror imputed values. 
  if (!('Lat' %in% names(lpti))) lpti1$Lat <- NA
  if (!('Long' %in% names(lpti))) lpti1$Long <- NA
  if (!all(sort(names(lpti)) == sort(names( lpti  %>%  total("", varnames = varnames, newrow = "World")) )))
    {print(sort(names( lpti  %>%  total("", varnames = varnames, newrow = "World"))))
    print("while " )
    print(sort(names(lpti)))
  }
  else TRUE  
}
  names(total(ECDC0, 'Europe' , ID = 'Region', varnames = c('confirmed','deaths'), newrow = 'Europe'))

```

```{r}
checkTotals3(ECDC0, 'Europe' , ID = 'Region')
```

# alternative sortIDlevels version which does not work. because of metaprogramming issues with arrange. 
```{r}
sortIDlevels.dplyr <- function(lpdf, varname = confirmed, ondate = ""){
  varname <- enquo(varname)
  if (ondate  == "") {ondate = max(lpdf$theDate) } else 
    if (nrow(lpdf[lpdf$theDate  ==  ondate, ]  == 0)) {
      stop("Cannot sort on values of a date which is not present in the Data")}
  PSCRlevels <- lpdf  %>%  select(c(PSCR, theDate, !!varname))  %>%  
    filter(theDate  == ondate)  %>%  
    arrange(-eval(parse(text = substitute(!!varname))), PSCR, .by_group  = FALSE) 
  arrange(desc({{varname}}), PSCR, .by_group  = FALSE) 
  #arrange(-(!!varname), PSCR, .by_group  = FALSE) 
  lpdf <- lpdf %>% ungroup %>%  mutate(PSCR = factor(lpdf$PSCR, levels = PSCRlevels$PSCR)) %>% 
    group_by(PSCR)
  lpdf$PSCR
} #the desc eval parse substitute !! should have been desc !! according to the manuals. but desc does not respect unquo. 
```
```{r}
JHH %>% filter(PSCR == "Belgium") %>% ysmooth("ma", c("new_confirmed", "net_active")) %>% #names #select(c(new_confirmed, net_active)) 
  tail

JHH %>% filter(PSCR == "Belgium")  %>%  #select(c(new_confirmed, net_active)) %>% 
  tail
     
```




```{r}
switch(labmeth,
       'none' = {},
       'dl_polygon' = {myplot = myplot + geom_dl(aes_string(x = xvar, y = "count",  label = 'mygroup'),
                 method  = list(dl.trans(x  = x + 0.1 , y = y + 0.1), "last.polygons", cex  = 1.2))
       xexpand = 0.25} ,
       'dl_bumpup' = {myplot = myplot + geom_dl(aes_string(x = xvar, y = "count",  label = 'mygroup'),
                method = list(dl.trans(x  = x + 0.1 , y = y + 0.1), "last.bumpup", cex  = 1.2))
       xexpand = 0.25} ,
       'label_repel' = {myplot = myplot + geom_label_repel(data = lpdf[lpdf[[xvar]] == max(lpdf[[xvar]]),], 
       aes(label = mygroup), label.size = 0.1, box.padding = 0.1, label.padding = 0.2, size = 3)
       xexpand = 0.35} ,
       'text_repel' = {myplot = myplot + geom_text_repel(data = lpdf[lpdf[[xvar]] == max(lpdf[[xvar]]),], 
        aes(label = mygroup), box.padding = 0.1, size = 3)
       xexpand = 0.4} ,
       {myplot = myplot + 
         geom_dl(aes_string(x = xvar, y = "count",  label = 'mygroup'),   #default
                method = list(dl.trans(x  = x + 0.1 , y = y + 0.1), "last.points", cex  = 1.2)) 
         xexpand = 0.35} 
)
```



# check addSimVars
```{r}
lpti <- ECDC[ECDC$PSCR %in% c("Cases_on_an_international_conveyance_Japan", "Cayman_Islands", "Central_African_Republic"),]
minVal <- 100; minDate = '2019-12-31'; maxDate = Sys.Date()

 for (country in countries <- unique(lpti$PSCR)) {
   
   if (any(is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))) { 
     print(country % % 'nrows' % % nrRows % % newnrRows) 
     print(which((is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))))}
 }

```

```{r}
country <- 'Cayman_Islands' 
print(which((is.na(lpti[lpti$PSCR == country ,c('confirmed','theDate')]))))
lpti[lpti$PSCR == country & lpti$confirmed >= minVal & lpti$theDate >= minDate & lpti$theDate <=  maxDate,] %>% view
```

```{r}
lpti %>% view
lpti %>% addSimVars(minVal = 100) #error. 
lpti <- ECDC[ECDC$PSCR %in% c("Cases_on_an_international_conveyance_Japan", "Cayman_Islands"),]
lpti %>% addSimVars(minVal = 100) #no error. 

```

```{r}
lpti[lpti$confirmed_doublingDays < 0, ] %>% view #39 totally NA rows 
lpti[is.na(lpti$confirmed_doublingDays), ] %>% view # 3172 rows

```

```{r}
ECDC[is.na(ECDC$PSCR),] %>% view()   #0 rows. 
E10 <- ECDC %>% addSimVars(minVal = 100) #error with Cayman_Islands
#
```

```{r do Europe}
lpti <- ECDC[ECDC$PSCR == 'Europe',]
lpti %>% addSimVars(minDate = Sys.Date() - 10, ext = "_endsim2") %>% view #one row less. 
options(warn = 2)
E10 <- ECDC %>% addSimVars(minDate = Sys.Date() - 10, ext = "_endsim") # europe -1 extra row generated this is ok. it was because Spain delivers data later. 
# 2020-07-05 data:  UK has 7 out of 11 rows. 2020-07-03: 10 out of 11
#
## also, NAs produced by rpois (42 times) and 
# In `[<-.data.frame`(`*tmp*`, lpti$PSCR == country, , value = structure(list( ... :
#provided 51 variables to replace 47 variables
```


# integrate testing into ECDC & JHH
```{r}
a <- merge(ECDC, testing, by.x = c('ISOcode','theDate'), by.y = c('ISOcode','theDate'), all.x = TRUE,
           sort = FALSE)
names(testing)
```
# from loaddata: trial to make the loading only happen if it gives new data
```{r}
while((Sys.time()>Sys.Date()% % "22:00:00")| max(JHH$theDate) < Sys.Date()-1 ) {
   source("loaddata.R")
   if (max(JHH$theDate)< Sys.Date() - 1)     {
    print( "failed to get yesterday's values ") 
   for (i in 1:12){
    print(Sys.time())
   Sys.sleep(600)
}   } }
```


# 12 ggplot extensions: ggcorplot, 
# https://mode.com/blog/r-ggplot-extension-packages
